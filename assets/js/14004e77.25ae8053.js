"use strict";(globalThis.webpackChunkphysical_ai_and_humanoid_robots=globalThis.webpackChunkphysical_ai_and_humanoid_robots||[]).push([[7491],{8453(e,i,n){n.d(i,{R:()=>t,x:()=>l});var o=n(6540);const r={},s=o.createContext(r);function t(e){const i=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),o.createElement(s.Provider,{value:i},e.children)}},9316(e,i,n){n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"module2/urdf-for-humanoids","title":"URDF for Humanoids - Describing Robot Anatomy","description":"Learn how Unified Robot Description Format (URDF) defines the physical characteristics of humanoid robots for simulation, visualization, and control in ROS 2.","source":"@site/docs/module2/03-urdf-for-humanoids.md","sourceDirName":"module2","slug":"/module2/urdf-for-humanoids","permalink":"/hackathon-humanoid-robotics-textbook/docs/module2/urdf-for-humanoids","draft":false,"unlisted":false,"editUrl":"https://github.com/Umm-e-Hani02/hackathon-humanoid-robotics-textbook/tree/main/docs/module2/03-urdf-for-humanoids.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"URDF for Humanoids - Describing Robot Anatomy","description":"Learn how Unified Robot Description Format (URDF) defines the physical characteristics of humanoid robots for simulation, visualization, and control in ROS 2.","keywords":["URDF","Humanoid Robots","Robot Anatomy","Kinematics","Xacro","ROS 2","Robot Simulation"]},"sidebar":"tutorialSidebar","previous":{"title":"rclpy + Python Agents in ROS 2","permalink":"/hackathon-humanoid-robotics-textbook/docs/module2/rclpy-python-agents"},"next":{"title":"Hands-on - Control a Simulated Joint via ROS 2 Nodes","permalink":"/hackathon-humanoid-robotics-textbook/docs/module2/hands-on-joint-control"}}');var r=n(4848),s=n(8453);const t={sidebar_position:3,title:"URDF for Humanoids - Describing Robot Anatomy",description:"Learn how Unified Robot Description Format (URDF) defines the physical characteristics of humanoid robots for simulation, visualization, and control in ROS 2.",keywords:["URDF","Humanoid Robots","Robot Anatomy","Kinematics","Xacro","ROS 2","Robot Simulation"]},l="URDF for Humanoids: Describing Robot Anatomy",a={},d=[{value:"What is URDF?",id:"what-is-urdf",level:2},{value:"Key Elements of a URDF File",id:"key-elements-of-a-urdf-file",level:3},{value:"A Simple Humanoid Segment Example (Conceptual)",id:"a-simple-humanoid-segment-example-conceptual",level:3},{value:"Xacro: Extending URDF",id:"xacro-extending-urdf",level:2},{value:"Why URDF is Essential for Humanoids",id:"why-urdf-is-essential-for-humanoids",level:2}];function c(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"urdf-for-humanoids-describing-robot-anatomy",children:"URDF for Humanoids: Describing Robot Anatomy"})}),"\n",(0,r.jsxs)(i.p,{children:["To effectively simulate, visualize, and control humanoid robots, we need a standardized way to describe their physical characteristics. The ",(0,r.jsx)(i.strong,{children:"Unified Robot Description Format (URDF)"})," serves this purpose within the ROS ecosystem. URDF is an XML-based file format used to describe all aspects of a robot, including its kinematic and dynamic properties, visual appearance, and collision models."]}),"\n",(0,r.jsx)(i.h2,{id:"what-is-urdf",children:"What is URDF?"}),"\n",(0,r.jsxs)(i.p,{children:["URDF defines a robot as a collection of ",(0,r.jsx)(i.strong,{children:"links"})," (rigid bodies) connected by ",(0,r.jsx)(i.strong,{children:"joints"})," (allowing relative motion between links). Each element within a URDF file contributes to a comprehensive model of the robot."]}),"\n",(0,r.jsx)(i.h3,{id:"key-elements-of-a-urdf-file",children:"Key Elements of a URDF File"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"<robot>"})," Tag"]}),": The root element, containing all other elements. It has a ",(0,r.jsx)(i.code,{children:"name"})," attribute for the robot."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"<link>"})," Tag"]}),": Describes a rigid body segment of the robot."]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"<visual>"})}),": Defines the visual properties of the link, such as its geometry (e.g., box, cylinder, sphere, mesh) and material (color, texture). This is what you see in a simulator or visualization tool."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"<collision>"})}),": Defines the collision properties of the link. This is used by physics engines to detect contact. Often a simplified version of the visual geometry to save computation."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"<inertial>"})}),": Defines the mass, center of mass, and inertia tensor of the link. Crucial for realistic physics simulation."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"<joint>"})," Tag"]}),": Describes the connection between two links."]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"name"})}),": Unique identifier for the joint."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"type"})}),": Specifies the joint's movement type (e.g., ",(0,r.jsx)(i.code,{children:"revolute"})," for rotation, ",(0,r.jsx)(i.code,{children:"prismatic"})," for linear motion, ",(0,r.jsx)(i.code,{children:"fixed"})," for no motion)."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"parent"})," / ",(0,r.jsx)(i.code,{children:"child"})]}),": Specifies which link is the parent and which is the child in the kinematic chain."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"<origin>"})}),": Defines the joint's position and orientation relative to its parent link."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"<axis>"})}),": For revolute and prismatic joints, defines the axis of motion."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"<limit>"})}),": For revolute and prismatic joints, defines the upper and lower position limits, velocity limits, and effort limits."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"<calibration>"}),", ",(0,r.jsx)(i.code,{children:"<dynamics>"}),", ",(0,r.jsx)(i.code,{children:"<safety_controller>"})]}),": Optional tags for fine-tuning joint behavior."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"a-simple-humanoid-segment-example-conceptual",children:"A Simple Humanoid Segment Example (Conceptual)"}),"\n",(0,r.jsxs)(i.p,{children:["Imagine a single leg segment of a humanoid. It would have a ",(0,r.jsx)(i.code,{children:"thigh"})," link connected to a ",(0,r.jsx)(i.code,{children:"shin"})," link by a ",(0,r.jsx)(i.code,{children:"knee"})," joint."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'<robot name="simple_humanoid_leg">\r\n\r\n  <link name="base_link" />\r\n\r\n  <link name="thigh">\r\n    <visual>\r\n      <geometry>\r\n        <cylinder length="0.4" radius="0.05" />\r\n      </geometry>\r\n      <material name="blue">\r\n        <color rgba="0 0 1 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <cylinder length="0.4" radius="0.05" />\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="2.0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  <link name="shin">\r\n    <visual>\r\n      <geometry>\r\n        <cylinder length="0.4" radius="0.05" />\r\n      </geometry>\r\n      <material name="red">\r\n        <color rgba="1 0 0 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <cylinder length="0.4" radius="0.05" />\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="1.5"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  <joint name="hip_joint" type="revolute">\r\n    <parent link="base_link"/>\r\n    <child link="thigh"/>\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n    <axis xyz="0 1 0"/>\r\n    <limit lower="-1.57" upper="1.57" velocity="1.0" effort="100"/>\r\n  </joint>\r\n\r\n  <joint name="knee_joint" type="revolute">\r\n    <parent link="thigh"/>\r\n    <child link="shin"/>\r\n    <origin xyz="0 0 -0.2" rpy="0 0 0"/> \x3c!-- Position relative to thigh end --\x3e\r\n    <axis xyz="0 1 0"/>\r\n    <limit lower="-1.57" upper="0" velocity="1.0" effort="100"/>\r\n  </joint>\r\n\r\n</robot>\n'})}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Note"}),": This is a simplified example. Real humanoid URDFs are much larger and often include meshes (for visuals) and more complex joint setups."]}),"\n",(0,r.jsx)(i.h2,{id:"xacro-extending-urdf",children:"Xacro: Extending URDF"}),"\n",(0,r.jsxs)(i.p,{children:["Writing large URDF files can be tedious and repetitive. ",(0,r.jsx)(i.strong,{children:"Xacro (XML Macros)"})," is a preprocessor for XML files (like URDF) that allows for more concise and readable descriptions. It enables:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Macros"}),": Define reusable blocks of XML."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Properties"}),": Define variables to avoid hardcoding values."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Mathematical Expressions"}),": Perform calculations within the file."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Conditional Inclusion"}),": Include or exclude parts of the description based on conditions."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Most complex humanoid robot descriptions use Xacro to generate the final URDF."}),"\n",(0,r.jsx)(i.h2,{id:"why-urdf-is-essential-for-humanoids",children:"Why URDF is Essential for Humanoids"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Simulation"}),": Physics engines (like Gazebo) use the inertial, collision, and joint properties to accurately simulate robot behavior."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Visualization"}),": Tools like RViz use the visual properties to render a 3D model of the robot."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Kinematics/Dynamics"}),": Software libraries use the link and joint descriptions to perform forward and inverse kinematics, and calculate dynamics."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Hardware Abstraction"}),": Provides a common interface for control algorithms, regardless of the underlying physical robot."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Understanding URDF is a foundational skill for anyone working with humanoid robots in simulation or real-world applications. In the next hands-on exercise, you will have the opportunity to control a simulated robot joint, applying some of the ROS 2 communication concepts with a robot described by URDF."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);