"use strict";(globalThis.webpackChunkphysical_ai_and_humanoid_robots=globalThis.webpackChunkphysical_ai_and_humanoid_robots||[]).push([[8865],{6829:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module4/hands-on-path-planning","title":"Hands-on - Plan a Path for a Humanoid Robot","description":"A conceptual exercise guiding you through planning a path for a humanoid robot using the Nav2 stack, focusing on configuration and workflow.","source":"@site/docs/module4/04-hands-on-path-planning.md","sourceDirName":"module4","slug":"/module4/hands-on-path-planning","permalink":"/hackathon-humanoid-robotics-textbook/docs/module4/hands-on-path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/Umm-e-Hani02/hackathon-humanoid-robotics-textbook/tree/main/docs/module4/04-hands-on-path-planning.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Hands-on - Plan a Path for a Humanoid Robot","description":"A conceptual exercise guiding you through planning a path for a humanoid robot using the Nav2 stack, focusing on configuration and workflow.","keywords":["Nav2","Path Planning","Humanoid Robots","ROS 2","Hands-on","Conceptual","Navigation"]},"sidebar":"tutorialSidebar","previous":{"title":"Nav2 for Humanoid Path Planning","permalink":"/hackathon-humanoid-robotics-textbook/docs/module4/nav2-path-planning"},"next":{"title":"Hardware Setup Guide - Workstation, Jetson, and Cloud","permalink":"/hackathon-humanoid-robotics-textbook/docs/hardware-setup/setup-guide"}}');var i=o(4848),r=o(8453);const t={sidebar_position:4,title:"Hands-on - Plan a Path for a Humanoid Robot",description:"A conceptual exercise guiding you through planning a path for a humanoid robot using the Nav2 stack, focusing on configuration and workflow.",keywords:["Nav2","Path Planning","Humanoid Robots","ROS 2","Hands-on","Conceptual","Navigation"]},s="Hands-on: Plan a Path for a Humanoid Robot (Conceptual)",l={},c=[{value:"Goal",id:"goal",level:2},{value:"Conceptual Steps",id:"conceptual-steps",level:2},{value:"1. Robot Model with Nav2 Compatibility",id:"1-robot-model-with-nav2-compatibility",level:3},{value:"2. Environment Setup",id:"2-environment-setup",level:3},{value:"3. Nav2 Configuration",id:"3-nav2-configuration",level:3},{value:"4. Nav2 Launch",id:"4-nav2-launch",level:3},{value:"5. Setting a Navigation Goal",id:"5-setting-a-navigation-goal",level:3},{value:"Observation",id:"observation",level:2},{value:"Challenges and Future Work",id:"challenges-and-future-work",level:2},{value:"Debugging Tips (Conceptual)",id:"debugging-tips-conceptual",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"hands-on-plan-a-path-for-a-humanoid-robot-conceptual",children:"Hands-on: Plan a Path for a Humanoid Robot (Conceptual)"})}),"\n",(0,i.jsx)(e.p,{children:"This hands-on exercise conceptually walks you through the steps involved in planning a path for a humanoid robot using the Nav2 stack within the ROS 2 ecosystem. While a full implementation requires a complex simulated humanoid and a fully configured Nav2 setup, understanding the workflow is crucial for future practical applications."}),"\n",(0,i.jsx)(e.h2,{id:"goal",children:"Goal"}),"\n",(0,i.jsx)(e.p,{children:"Understand the high-level process of configuring Nav2 components to generate a path for a humanoid robot in a simulated environment."}),"\n",(0,i.jsx)(e.h2,{id:"conceptual-steps",children:"Conceptual Steps"}),"\n",(0,i.jsx)(e.h3,{id:"1-robot-model-with-nav2-compatibility",children:"1. Robot Model with Nav2 Compatibility"}),"\n",(0,i.jsxs)(e.p,{children:["Assume you have a simulated humanoid robot loaded in Gazebo (or Isaac Sim) that is correctly described by a URDF/SDF file, has a configured ",(0,i.jsx)(e.code,{children:"robot_state_publisher"}),", and its joints are controllable via ROS 2."]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Key"}),": The robot must have sensors (e.g., LiDAR or depth camera for mapping/localization) and an interface to receive locomotion commands."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Locomotion Interface"}),": For humanoids, this means an interface that translates ",(0,i.jsx)(e.code,{children:"Twist"})," commands (linear/angular velocities from Nav2's local planner) into stable walking gaits and joint commands. This is often a specialized humanoid locomotion controller."]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"2-environment-setup",children:"2. Environment Setup"}),"\n",(0,i.jsx)(e.p,{children:"You need a known environment, either pre-built in your simulator's world file or mapped in real-time. For this exercise, assume a static map."}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"World File"}),": A simulated world with some obstacles."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Map"}),": A 2D occupancy grid map (",(0,i.jsx)(e.code,{children:".pgm"})," and ",(0,i.jsx)(e.code,{children:".yaml"})," files) that Nav2 can load, representing the traversable and untraversable areas."]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"3-nav2-configuration",children:"3. Nav2 Configuration"}),"\n",(0,i.jsxs)(e.p,{children:["Nav2 is highly configurable through YAML files. You'll have multiple configuration files for different Nav2 components (e.g., ",(0,i.jsx)(e.code,{children:"amcl.yaml"}),", ",(0,i.jsx)(e.code,{children:"global_planner.yaml"}),", ",(0,i.jsx)(e.code,{children:"local_planner.yaml"}),", ",(0,i.jsx)(e.code,{children:"costmap.yaml"}),")."]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsxs)(e.strong,{children:[(0,i.jsx)(e.code,{children:"costmap.yaml"})," Considerations for Humanoids"]}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Footprint"}),": A humanoid doesn't have a simple circular or rectangular footprint. Nav2 allows for complex polygon footprints. This needs to be defined to reflect the humanoid's true collision bounds."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Inflation Radius"}),": The area around obstacles that Nav2 considers unsafe. For humanoids, this might need careful tuning, considering their ability to step over small obstacles."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Layers"}),": Configuration of static, obstacle, and inflation layers. Dynamic obstacle layers would process real-time sensor data."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsxs)(e.strong,{children:[(0,i.jsx)(e.code,{children:"local_planner.yaml"})," (Controller) Adaptation"]}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["The ",(0,i.jsx)(e.code,{children:"local_planner"})," (e.g., DWB, TEB) generates ",(0,i.jsx)(e.code,{children:"Twist"})," messages. For humanoids, this ",(0,i.jsx)(e.code,{children:"Twist"})," needs to be consumed by a dedicated walking controller."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Custom Controller Plugin"}),": In a real scenario, you might write a custom Nav2 controller plugin that interfaces directly with your humanoid's locomotion system, bypassing the standard ",(0,i.jsx)(e.code,{children:"Twist"})," to motor command conversion directly."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"4-nav2-launch",children:"4. Nav2 Launch"}),"\n",(0,i.jsx)(e.p,{children:"You would typically launch the entire Nav2 stack using a ROS 2 launch file."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Conceptual Nav2 Launch File for a Humanoid --\x3e\r\n<launch>\r\n  \x3c!-- Launch your simulated humanoid in Gazebo/Isaac Sim --\x3e\r\n  <include file="path/to/your/humanoid_sim_launch.py"/>\r\n\r\n  \x3c!-- Launch Nav2 components --\x3e\r\n  <group>\r\n    <push-ros-namespace namespace="your_humanoid_robot"/> \x3c!-- Namespace for multi-robot systems --\x3e\r\n\r\n    <node pkg="nav2_map_server" exec="map_server" name="map_server">\r\n      <param name="yaml_filename" value="path/to/your/map.yaml"/>\r\n    </node>\r\n\r\n    <node pkg="nav2_amcl" exec="amcl" name="amcl">\r\n      <param from="path/to/your/amcl_config.yaml"/>\r\n    </node>\r\n\r\n    <node pkg="nav2_controller" exec="controller_server" name="controller_server">\r\n      <param from="path/to/your/controller_config.yaml"/>\r\n    </node>\r\n\r\n    <node pkg="nav2_planner" exec="planner_server" name="planner_server">\r\n      <param from="path/to/your/planner_config.yaml"/>\r\n    </node>\r\n\r\n    <node pkg="nav2_behaviors" exec="behavior_server" name="behavior_server">\r\n      <param from="path/to/your/behavior_config.yaml"/>\r\n    </node>\r\n\r\n    <node pkg="nav2_bt_navigator" exec="bt_navigator" name="bt_navigator">\r\n      <param from="path/to/your/bt_navigator_config.yaml"/>\r\n    </node>\r\n\r\n    <node pkg="nav2_lifecycle_manager" exec="lifecycle_manager" name="lifecycle_manager">\r\n      <param name="node_names" value="[\'map_server\', \'amcl\', \'controller_server\', \'planner_server\', \'behavior_server\', \'bt_navigator\']"/>\r\n    </node>\r\n  </group>\r\n</launch>\n'})}),"\n",(0,i.jsx)(e.h3,{id:"5-setting-a-navigation-goal",children:"5. Setting a Navigation Goal"}),"\n",(0,i.jsxs)(e.p,{children:["Once Nav2 is launched and the robot is localized, you can set a navigation goal using the ",(0,i.jsx)(e.code,{children:"2D Pose Estimate"})," and ",(0,i.jsx)(e.code,{children:"2D Goal Pose"})," tools in RViz (ROS Visualization)."]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Initial Pose Estimate"}),": Use the ",(0,i.jsx)(e.code,{children:"2D Pose Estimate"})," tool to tell Nav2 the robot's approximate starting position and orientation on the map. AMCL will then refine this."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Goal Pose"}),": Use the ",(0,i.jsx)(e.code,{children:"2D Goal Pose"})," tool to click a target location on the map and drag to set the desired final orientation for the robot."]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"observation",children:"Observation"}),"\n",(0,i.jsx)(e.p,{children:"If everything is configured correctly:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Nav2 will compute a global path to the goal, visible in RViz."}),"\n",(0,i.jsx)(e.li,{children:"The local planner will start generating commands."}),"\n",(0,i.jsx)(e.li,{children:"Your humanoid robot's locomotion controller will receive these commands and execute a walking gait, navigating around obstacles."}),"\n",(0,i.jsx)(e.li,{children:"The humanoid will ideally reach the target pose."}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"challenges-and-future-work",children:"Challenges and Future Work"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Humanoid-Specific Motion"}),": The primary challenge is creating a robust humanoid locomotion controller that can smoothly execute Nav2's ",(0,i.jsx)(e.code,{children:"Twist"})," commands."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic Environments"}),": Adapting Nav2 to handle highly dynamic humanoid environments (e.g., crowded spaces) requires advanced obstacle detection and prediction."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Stair Climbing/Uneven Terrain"}),": Standard Nav2 doesn't inherently support multi-level navigation or complex terrain traversal. This would require significant custom development or integration with specialized humanoid planners."]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This conceptual exercise highlights that while Nav2 provides a powerful framework, its application to humanoid robots often necessitates custom development and careful integration with humanoid-specific control systems."}),"\n",(0,i.jsx)(e.h2,{id:"debugging-tips-conceptual",children:"Debugging Tips (Conceptual)"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Nav2 Launch Failures"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Check individual node logs (e.g., ",(0,i.jsx)(e.code,{children:"ros2 run --prefix 'gdb -ex run --args' nav2_amcl amcl --ros-args -p use_sim_time:=True"}),")."]}),"\n",(0,i.jsx)(e.li,{children:"Verify that all required configuration YAML files are correctly located and readable."}),"\n",(0,i.jsx)(e.li,{children:"Ensure all necessary ROS 2 packages are installed."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"No Path Generated"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Goal Reachable?"}),": Is the goal within the navigable area of the map? Is it too close to an obstacle (considering inflation radius)?"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Localization"}),": Is the robot accurately localized (",(0,i.jsx)(e.code,{children:"AMCL"})," working correctly)? Check ",(0,i.jsx)(e.code,{children:"tf tree"})," and the pose in RViz."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Global Planner Parameters"}),": Review the global planner's configuration (e.g., ",(0,i.jsx)(e.code,{children:"planner_server"})," in ",(0,i.jsx)(e.code,{children:"nav2_params.yaml"}),")."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Robot Not Moving"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Locomotion Controller"}),": Is your humanoid locomotion controller correctly receiving and interpreting the ",(0,i.jsx)(e.code,{children:"Twist"})," commands from Nav2's local planner?"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Safety Limits"}),": Are there velocity or acceleration limits in your robot's controller or Nav2 configuration that are preventing movement?"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Obstacle Avoidance Issues"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Costmap Visualization"}),': In RViz, visualize the costmap to see what Nav2 "perceives" as obstacles. Is your sensor data feeding into the costmap correctly?']}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Inflation Radius"}),": Adjust the inflation radius in ",(0,i.jsx)(e.code,{children:"costmap.yaml"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Sensor Data"}),": Check if sensor data (LiDAR, depth camera) is being published to the correct topics and is free of major errors."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:'"Waiting for transform..." Errors'}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsxs)(e.strong,{children:[(0,i.jsx)(e.code,{children:"tf"})," Tree"]}),": This usually indicates a problem with the ",(0,i.jsx)(e.code,{children:"tf"})," (Transformation Frame) tree. Ensure ",(0,i.jsx)(e.code,{children:"robot_state_publisher"})," is running and publishing the correct transforms between your robot's links."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.code,{children:"use_sim_time"})}),": If using simulation, ensure ",(0,i.jsx)(e.code,{children:"use_sim_time"})," is set to ",(0,i.jsx)(e.code,{children:"True"})," for all Nav2 nodes and your simulation."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Debugging Nav2 with a complex robot like a humanoid requires a systematic approach, often starting from the sensor data, verifying localization, checking path planning, and finally ensuring the locomotion controller correctly executes the commands."})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>t,x:()=>s});var a=o(6540);const i={},r=a.createContext(i);function t(n){const e=a.useContext(r);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:t(n.components),a.createElement(r.Provider,{value:e},n.children)}}}]);