"use strict";(globalThis.webpackChunkphysical_ai_and_humanoid_robots=globalThis.webpackChunkphysical_ai_and_humanoid_robots||[]).push([[1423],{4186:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module3/hands-on-obstacle-course","title":"Hands-on - Simulate Robot in Obstacle Course","description":"A conceptual hands-on exercise to understand the process of setting up a simulated environment with obstacles and programming a robot for navigation.","source":"@site/docs/module3/04-hands-on-obstacle-course.md","sourceDirName":"module3","slug":"/module3/hands-on-obstacle-course","permalink":"/hackathon-humanoid-robotics-textbook/docs/module3/hands-on-obstacle-course","draft":false,"unlisted":false,"editUrl":"https://github.com/Umm-e-Hani02/hackathon-humanoid-robotics-textbook/tree/main/docs/module3/04-hands-on-obstacle-course.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Hands-on - Simulate Robot in Obstacle Course","description":"A conceptual hands-on exercise to understand the process of setting up a simulated environment with obstacles and programming a robot for navigation.","keywords":["Simulated Robot","Obstacle Course","ROS 2","Gazebo","Robot Navigation","Hands-on","Conceptual Exercise"]},"sidebar":"tutorialSidebar","previous":{"title":"Sensor Simulation - LiDAR, Depth, and IMU","permalink":"/hackathon-humanoid-robotics-textbook/docs/module3/sensor-simulation"},"next":{"title":"NVIDIA Isaac SDK & Isaac Sim","permalink":"/hackathon-humanoid-robotics-textbook/docs/module4/isaac-sdk-and-sim"}}');var i=o(4848),t=o(8453);const a={sidebar_position:4,title:"Hands-on - Simulate Robot in Obstacle Course",description:"A conceptual hands-on exercise to understand the process of setting up a simulated environment with obstacles and programming a robot for navigation.",keywords:["Simulated Robot","Obstacle Course","ROS 2","Gazebo","Robot Navigation","Hands-on","Conceptual Exercise"]},r="Hands-on: Simulate a Robot Moving Through an Obstacle Course",l={},c=[{value:"Goal",id:"goal",level:2},{value:"Conceptual Steps",id:"conceptual-steps",level:2},{value:"1. Define the Robot (URDF/SDF)",id:"1-define-the-robot-urdfsdf",level:3},{value:"2. Design the Obstacle Course (World File)",id:"2-design-the-obstacle-course-world-file",level:3},{value:"3. Launch the Simulation (ROS 2 Launch File)",id:"3-launch-the-simulation-ros-2-launch-file",level:3},{value:"4. Navigation Stack (Conceptual)",id:"4-navigation-stack-conceptual",level:3},{value:"5. Writing a Simple Navigation Controller (Conceptual Python)",id:"5-writing-a-simple-navigation-controller-conceptual-python",level:3},{value:"Reflection Questions",id:"reflection-questions",level:2},{value:"Debugging Tips (Conceptual)",id:"debugging-tips-conceptual",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"hands-on-simulate-a-robot-moving-through-an-obstacle-course",children:"Hands-on: Simulate a Robot Moving Through an Obstacle Course"})}),"\n",(0,i.jsx)(n.p,{children:"This hands-on exercise will guide you through the conceptual steps of setting up a simulated environment with obstacles and programming a simple robot to navigate through it. We will use a conceptual approach, outlining the typical workflow with tools like Gazebo and ROS 2, rather than a full code implementation, as that would require a complex setup beyond the scope of a single lesson."}),"\n",(0,i.jsx)(n.h2,{id:"goal",children:"Goal"}),"\n",(0,i.jsx)(n.p,{children:"Understand the process of defining an environment, placing obstacles, and conceptualizing robot navigation within a simulated world."}),"\n",(0,i.jsx)(n.h2,{id:"conceptual-steps",children:"Conceptual Steps"}),"\n",(0,i.jsx)(n.h3,{id:"1-define-the-robot-urdfsdf",children:"1. Define the Robot (URDF/SDF)"}),"\n",(0,i.jsx)(n.p,{children:"First, you need a robot model. For this exercise, assume you have a simple differential drive robot or a bipedal humanoid described in a URDF or SDF file. This model includes its physical dimensions, sensor definitions (e.g., LiDAR, depth camera), and joint configurations."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Key components for navigation"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Base Link"}),": The main body of the robot."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Wheels/Feet"}),": For locomotion."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensors"}),": LiDAR or a depth camera for obstacle detection, IMU for odometry."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-design-the-obstacle-course-world-file",children:"2. Design the Obstacle Course (World File)"}),"\n",(0,i.jsx)(n.p,{children:'In simulators like Gazebo, environments are defined in "world" files (XML or SDF). You would design a simple rectangular arena and populate it with basic obstacles.'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ground Plane"}),": A flat surface for the robot to move on."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Walls"}),": Boundary walls to keep the robot within the arena."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simple Obstacles"}),": Cubes, cylinders, or other simple shapes strategically placed to create a path for the robot to navigate around."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Conceptual World Snippet"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example: defining an obstacle in a Gazebo world file --\x3e\r\n<model name="wall_obstacle">\r\n  <pose>1 0 0.5 0 0 0</pose> \x3c!-- Position (x, y, z) and orientation (roll, pitch, yaw) --\x3e\r\n  <link name="link">\r\n    <collision name="collision">\r\n      <geometry>\r\n        <box>\r\n          <size>0.1 2 1</size> \x3c!-- Thickness, Length, Height --\x3e\r\n        </box>\r\n      </geometry>\r\n    </collision>\r\n    <visual name="visual">\r\n      <geometry>\r\n        <box>\r\n          <size>0.1 2 1</size>\r\n        </box>\r\n      </geometry>\r\n      <material>\r\n        <ambient>0.8 0.8 0.8 1</ambient>\r\n        <diffuse>0.8 0.8 0.8 1</diffuse>\r\n      </material>\r\n    </visual>\r\n  </link>\r\n</model>\n'})}),"\n",(0,i.jsx)(n.p,{children:"You would replicate this for several obstacles to form a course."}),"\n",(0,i.jsx)(n.h3,{id:"3-launch-the-simulation-ros-2-launch-file",children:"3. Launch the Simulation (ROS 2 Launch File)"}),"\n",(0,i.jsx)(n.p,{children:"A ROS 2 launch file would bring up Gazebo with your chosen world and spawn your robot model."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Launch Gazebo"}),": Start the Gazebo server and client."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Spawn Robot"}),": Load your robot's URDF/SDF into the Gazebo world."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robot State Publisher"}),": Publish the robot's joint states and TF transformations."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensor Plugins"}),": Ensure your robot's sensors (LiDAR, IMU, camera) are active and publishing data to ROS 2 topics."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-navigation-stack-conceptual",children:"4. Navigation Stack (Conceptual)"}),"\n",(0,i.jsxs)(n.p,{children:["For autonomous navigation through an obstacle course, you would typically use a navigation stack. In ROS 2, this is often the ",(0,i.jsx)(n.strong,{children:"Nav2"})," stack, but for a conceptual understanding, let's consider the core components:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mapping"}),": A map of the environment is needed. This can be pre-built (from your world file) or generated in real-time (SLAM - Simultaneous Localization and Mapping) using sensor data (e.g., LiDAR)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Localization"}),": The robot needs to know its position within the map. This is achieved using sensors like LiDAR or IMU data combined with techniques like Monte Carlo Localization (AMCL)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Path Planning"}),": Given a start and goal position on the map, a global planner computes an optimal path (e.g., using A* or Dijkstra's algorithm) that avoids known obstacles."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Local Planning/Collision Avoidance"}),": As the robot moves, a local planner continuously adjusts the path to avoid unforeseen obstacles (detected by real-time sensor data) and to follow the global path."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Controller"}),": Commands are sent to the robot's motors (e.g., target velocities for wheels, joint angles for legs) to execute the planned path."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"5-writing-a-simple-navigation-controller-conceptual-python",children:"5. Writing a Simple Navigation Controller (Conceptual Python)"}),"\n",(0,i.jsx)(n.p,{children:"Imagine a simplified Python script (ROS 2 node) that takes sensor data and sends velocity commands."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Conceptual Python navigation node snippet\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist # For sending velocity commands\r\nfrom sensor_msgs.msg import LaserScan # For LiDAR data\r\n\r\nclass SimpleNavigator(Node):\r\n    def __init__(self):\r\n        super().__init__('simple_navigator_node')\r\n        self.publisher_ = self.create_publisher(Twist, '/cmd_vel', 10)\r\n        self.subscription = self.create_subscription(\r\n            LaserScan,\r\n            '/scan', # LiDAR topic\r\n            self.laser_callback,\r\n            10)\r\n        self.get_logger().info('Simple Navigator Node started.')\r\n        self.cmd_vel_msg = Twist()\r\n        self.obstacle_detected = False\r\n\r\n    def laser_callback(self, msg):\r\n        # Very simplistic obstacle detection: check front-facing laser beams\r\n        # For a humanoid, this might involve more complex analysis\r\n        min_distance_front = min(msg.ranges[len(msg.ranges)//4 : 3*len(msg.ranges)//4]) # Front 50%\r\n        if min_distance_front < 0.5: # If obstacle within 0.5 meters\r\n            self.obstacle_detected = True\r\n        else:\r\n            self.obstacle_detected = False\r\n\r\n        self.navigate() # Make navigation decision after each scan\r\n\r\n    def navigate(self):\r\n        if self.obstacle_detected:\r\n            self.get_logger().warn('Obstacle detected! Turning...')\r\n            self.cmd_vel_msg.linear.x = 0.0 # Stop\r\n            self.cmd_vel_msg.angular.z = 0.5 # Turn left\r\n        else:\r\n            self.get_logger().info('Path clear, moving forward.')\r\n            self.cmd_vel_msg.linear.x = 0.2 # Move forward\r\n            self.cmd_vel_msg.angular.z = 0.0 # Straight\r\n        self.publisher_.publish(self.cmd_vel_msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    simple_navigator = SimpleNavigator()\r\n    rclpy.spin(simple_navigator)\r\n    simple_navigator.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.p,{children:"This conceptual script demonstrates how a robot could react to obstacles based on sensor data. A real navigation stack (like Nav2) would involve much more sophisticated algorithms for mapping, localization, global planning, and local planning."}),"\n",(0,i.jsx)(n.h2,{id:"reflection-questions",children:"Reflection Questions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What are the main challenges in defining a realistic obstacle course?"}),"\n",(0,i.jsx)(n.li,{children:"How would a humanoid robot's navigation strategy differ from a wheeled robot's?"}),"\n",(0,i.jsx)(n.li,{children:"What additional sensors would be beneficial for navigating a complex environment?"}),"\n",(0,i.jsx)(n.li,{children:"How would you evaluate the success of a robot navigating an obstacle course in simulation?"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This exercise provides a high-level overview of the components and conceptual steps involved in simulating a robot's navigation through an obstacle course, laying the groundwork for more advanced navigation techniques."}),"\n",(0,i.jsx)(n.h2,{id:"debugging-tips-conceptual",children:"Debugging Tips (Conceptual)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simulation Freezing/Crashing"}),": In full simulators like Gazebo, this often indicates a problem with the robot model (URDF/SDF), such as invalid joint limits, self-collisions, or incorrect inertial properties. Check the simulator's logs for specific errors."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robot Not Moving"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Control Interface"}),": Ensure your locomotion controller is correctly subscribed to the Nav2 local planner's output (e.g., ",(0,i.jsx)(n.code,{children:"/cmd_vel"}),") and is translating those commands into motor actions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Power/Physics"}),": In simulation, check if the robot has sufficient power or if physics parameters (friction, mass) are preventing movement."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Incorrect Path Planning"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Map Issues"}),": Verify the map provided to Nav2 is accurate and up-to-date."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Costmap Configuration"}),": Review the ",(0,i.jsx)(n.code,{children:"costmap.yaml"})," parameters. Is the inflation radius appropriate? Are static and dynamic obstacles being correctly integrated?"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Planner Parameters"}),": Global and local planner parameters (e.g., maximum velocities, acceleration limits) can significantly affect planning behavior."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Localization Errors"}),': If the robot "drifts" or gets lost:',"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensor Noise"}),": Is the simulated sensor data too noisy or too clean? Realistic noise models are important."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"AMCL Parameters"}),": Tune AMCL's parameters (e.g., particle count, update rates) for your specific environment and sensor types."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Obstacle Avoidance Failures"}),": If the robot collides with obstacles:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensor Range/FOV"}),': Ensure sensors can "see" obstacles early enough.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Local Planner Tuning"}),": Adjust the local planner's aggressiveness and obstacle avoidance parameters."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Footprint/Collision Model"}),": Double-check that the robot's collision model in the URDF/SDF accurately represents its physical dimensions."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>r});var s=o(6540);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);